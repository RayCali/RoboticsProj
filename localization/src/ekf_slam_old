#!/usr/bin/python3
import rospy
from geometry_msgs.msg import TransformStamped
from robp_msgs.msg import Encoders
import tf_conversions
import tf2_ros
import tf2_msgs.msg
import tf2_geometry_msgs
import tf
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Point
from aruco_msgs.msg import MarkerArray
import math
from visualization_msgs.msg import Marker
import numpy as np
x=0
y=0
yaw=0
br= None
tfBuffer = None
listener = None
R = np.identity(3)*0.01
Q = np.identity(2)*0.01
H = np.array([[-1,0,0,1,0],[0,-1,0,0,1]])
landmarks = 1
firsttime0 = True
firsttime1 = True
firsttime2 = True
mu = np.zeros(3+2*landmarks)
P_up = np.zeros([3,3+2*landmarks])
p_downleft = np.zeros([2*landmarks,3])
p_downright = np.identity(2*landmarks)*(10**9)
p_down = np.concatenate((p_downleft,p_downright),axis=1)
P = np.concatenate((P_up,p_down),axis=0)
Fxmapcols = np.zeros([3,2*landmarks])
Fxposcols = np.identity(3)
Fx = np.concatenate((Fxmapcols,Fxposcols),axis=1)
G = np.zeros([3+2*landmarks,3+2*landmarks])
G[3:3+2*landmarks,3:3+2*landmarks]=np.identity(2*landmarks)
latestupdate = None
def encoder_callback(msg):
    global x,y,yaw,Fx,mu,P,G, tfBuffer
   
    br = tf2_ros.TransformBroadcaster()

    t = TransformStamped()
    t.header.frame_id = "odom"
    t.child_frame_id = "base_link"
    
    # 2*math.pi/3072 = radians per tick
    r= 0.04921
    dt=1/20
    b=0.3
    vw_1 = msg.delta_encoder_left*2*math.pi*20*r/3072
    vw_2 = msg.delta_encoder_right*2*math.pi*20*r/3072
    v = (vw_1+vw_2)/2
    w= (vw_2-vw_1)/(b)
    diffx=v*dt*math.cos(yaw)
    diffy=v*dt*math.sin(yaw)
    difftheta=w*dt
    x = x+diffx
    y = y+diffy
    yaw = yaw+difftheta
    mu[0]=mu[0]+diffx
    mu[1]=mu[1]+diffy
    mu[2]=mu[2]+difftheta
    Gx = np.array([[1,0,-v*dt*math.sin(yaw)],[0,1,v*dt*math.cos(yaw)],[0,0,1]])
    G[0:3,0:3]=Gx
    P = np.matmul(np.matmul(G,P),np.transpose(G)) + np.matmul(np.matmul(np.transpose(Fx),R),Fx)
    t.header.stamp=msg.header.stamp
    t.transform.translation.x = x
    t.transform.translation.y = y
    q = tf_conversions.transformations.quaternion_from_euler(0, 0, yaw)
    t.transform.rotation.x = q[0]
    t.transform.rotation.y = q[1]
    t.transform.rotation.z = q[2]
    t.transform.rotation.w = q[3]
    br.sendTransform(t)
    transformblmap = tfBuffer.lookup_transform('map', 'base_link', msg.header.stamp, rospy.Duration(1.0))
    mu[0] = transformblmap.transform.translation.x
    mu[1] = transformblmap.transform.translation.y
    anglelist = [transformblmap.transform.rotation.x, transformblmap.transform.rotation.y, transformblmap.transform.rotation.z,transformblmap.transform.rotation.w]
    roll,pitch,yaw2 = tf_conversions.transformations.euler_from_quaternion(anglelist)
    mu[2] = yaw2

def update_callback(msg: MarkerArray):
    global x,y,yaw,Fx,mu,P,G, tfBuffer, listener, firsttime0, firsttime1, firsttime2,R,br,latestupdate
    for mark in msg.markers:
        if mark.id !=2:
            time = rospy.Time(0)
            transform = tfBuffer.lookup_transform('map', 'camera_link', time, rospy.Duration(1.0))
            markerpose = tf2_geometry_msgs.do_transform_pose(mark.pose, transform)
            if mark.id == 1:
                if firsttime0:
                    rospy.loginfo("found one")
                    mu[3],mu[4]=markerpose.pose.position.x,markerpose.pose.position.y
                    P[3:5,3:5]= P[0:2,0:2]
                    marktransform = TransformStamped()
                    marktransform.header.frame_id = "map"
                    marktransform.child_frame_id = "arucolandmark"
                    marktransform.header.stamp = msg.header.stamp
                    marktransform.transform.translation.x = markerpose.pose.position.x
                    marktransform.transform.translation.y = markerpose.pose.position.y
                    marktransform.transform.translation.z = markerpose.pose.position.z
                    anglelist = [markerpose.pose.orientation.x, markerpose.pose.orientation.y, markerpose.pose.orientation.z,markerpose.pose.orientation.w]
                    roll,pitch,yaw2 = tf_conversions.transformations.euler_from_quaternion(anglelist)
                    roll = roll - math.pi/2
                    yaw2 = yaw2 - math.pi/2
                    q = tf_conversions.transformations.quaternion_from_euler(roll, pitch, yaw2)
                    marktransform.transform.rotation.x =  q[0]      #markerpose.pose.orientation.x
                    marktransform.transform.rotation.y =  q[1]      #markerpose.pose.orientation.y
                    marktransform.transform.rotation.z =  q[2]      #markerpose.pose.orientation.z
                    marktransform.transform.rotation.w =  q[3]      #markerpose.pose.orientation.w
                    br.sendTransform(marktransform)
                    firsttime0 = False
                    latestupdate = rospy.Time.now()
                #if rospy.Time.now().to_sec() - latestupdate.to_sec() > 10:
                
                    
                addon = np.zeros([2,3+2*landmarks])
                addon[0,3]= 1
                addon[1,4]= 1
                Fxj = np.concatenate((Fx,addon),axis=0)
                
                
                #range bearing part
                delta = np.array([mu[3]-mu[0],mu[4]-mu[1]])
                q = np.matmul(np.transpose(delta),delta)
                zpredict = np.array([math.sqrt(q),math.atan2(delta[1],delta[0])-mu[2]])
                H = 1/q*np.array([[-math.sqrt(q)*delta[0],-math.sqrt(q)*delta[1],0,math.sqrt(q)*delta[0],math.sqrt(q)*delta[1]],[delta[1],-delta[0],-q,-delta[1],delta[0]]])
                transformb = tfBuffer.lookup_transform('base_link', 'camera_link', time, rospy.Duration(1.0))
                markerposeb = tf2_geometry_msgs.do_transform_pose(mark.pose, transformb)
                delta = np.array([markerposeb.pose.position.x,markerposeb.pose.position.y])
                q = np.matmul(np.transpose(delta),delta)
                z = np.array([math.sqrt(q),math.atan2(delta[1],delta[0])])
                Hj = np.matmul(H,Fxj)
                
                
                
                K = np.matmul(np.matmul(P,np.transpose(Hj)),np.linalg.inv(np.matmul(np.matmul(Hj,P),np.transpose(Hj))+Q))

                mu = mu + np.matmul(K,z-zpredict)
                rospy.loginfo(np.matmul(K,z-zpredict))
                
                #diff = np.dot(K,np.array([markerpose.pose.position.x-mu[0]-mu[3]+mu[0],markerpose.pose.position.y-mu[1] - mu[4] + mu[1]]))
                #mu = mu + diff
                #rospy.loginfo("diff: %s",diff)




                transformod = tfBuffer.lookup_transform('map', 'odom', time, rospy.Duration(1.0))
                anglelist = [transformod.transform.rotation.x, transformod.transform.rotation.y, transformod.transform.rotation.z,transformod.transform.rotation.w]
                roll,pitch,yaw2 = tf_conversions.transformations.euler_from_quaternion(anglelist)
                #yawnew = yaw2 + diff[2] 
                yawnew = yaw2 + np.matmul(K,z-zpredict)[2]
                q = tf_conversions.transformations.quaternion_from_euler(0, 0, yawnew)
                newodom = TransformStamped()
                newodom.header.frame_id = "map"
                newodom.child_frame_id = "odom"
                newodom.header.stamp = msg.header.stamp
                newodom.transform.translation.x = np.matmul(K,z-zpredict)[0] + transformod.transform.translation.x
                newodom.transform.translation.y = np.matmul(K,z-zpredict)[1] + transformod.transform.translation.y
                newodom.transform.translation.z = 0
                newodom.transform.rotation.x =  q[0]
                newodom.transform.rotation.y =  q[1]
                newodom.transform.rotation.z =  q[2]
                newodom.transform.rotation.w =  q[3]
                br.sendTransform(newodom)




                latestupdate = rospy.Time.now()
                P = np.matmul(np.identity(3+2*landmarks)-np.matmul(K,Hj),P)
                marktransform = TransformStamped()
                marktransform.header.frame_id = "map"
                marktransform.child_frame_id = "arucolandmark"
                marktransform.header.stamp = msg.header.stamp
                marktransform.transform.translation.x = mu[3]
                marktransform.transform.translation.y = mu[4]
                marktransform.transform.translation.z = markerpose.pose.position.z
                marktransform.transform.rotation.x =  0      #markerpose.pose.orientation.x
                marktransform.transform.rotation.y =  0      #markerpose.pose.orientation.y
                marktransform.transform.rotation.z =  0      #markerpose.pose.orientation.z
                marktransform.transform.rotation.w =  1      #markerpose.pose.orientation.w
                br.sendTransform(marktransform)

                rospy.loginfo("updated")
                    
            elif mark.id == 1:
                if firsttime1:
                    mu[5:7]=np.array([markerpose.pose.position.x,markerpose.pose.position.y])
                    firsttime1 = False
            elif mark.id == 2:
                if firsttime2:
                    mu[7:9]=np.array([markerpose.pose.position.x,markerpose.pose.position.y])
                    firsttime2 = False
        else:
            
            P[0:3,0:3].fill(0)

if __name__ == '__main__':
    rospy.init_node('ekf_slam')
    sub_goal = rospy.Subscriber('/motor/encoders', Encoders, encoder_callback)
    update = rospy.Subscriber('/aruco/markers', MarkerArray, update_callback)
    tfBuffer = tf2_ros.Buffer(rospy.Duration(12000.0))
    listener = tf2_ros.TransformListener(tfBuffer)
    br = tf2_ros.TransformBroadcaster()
    
    while not rospy.is_shutdown():
        continue
    
    rospy.spin()